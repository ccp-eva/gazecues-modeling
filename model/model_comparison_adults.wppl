// example call: time webppl model_comparison_adults.wppl --require webppl-json --require webppl-sample-writer 1

var chain = last(process.argv)

// helper functions

var foreach = function(fn, lst) {
    var foreach_ = function(i) {
        if (i < lst.length) {
            fn(lst[i]);
            foreach_(i + 1);
        }
    };
    foreach_(0);
};

var samplePosGaussian = function(mu, sigma) {
    var x = sample(Gaussian({ mu: mu, sigma: sigma }))
    return x < 0 ? samplePosGaussian(mu, sigma) : x
};

var logistic = function(x) { 1 / (1 + Math.exp(-x)) }

var multiply = function(x, y) { return x * y; };

var levels = function(df, label) {
    return _.uniq(_.map(df, label));
}

var deg2rad = function(x) {
    (x * Math.PI) / (180)
}

// data

var data = json.read('model_data/model_data_adults.json');

var subjects = levels(data, "subjID")

var maxCoord = 1920

var granularity = 20

var granCoord = maxCoord / granularity

var cords = _.range(0, granCoord)

var sampleCoord = map(function(x) {
    return x * granularity;
}, cords)

var coordinates = _.range(0, 1920)

var model = function() {

    var sdInf = gaussianDrift({ mu: -1, sigma: 1, width: 0.1 })
    var infSigma = uniformDrift({ a: 0, b: 1, width: 0.1 })

    var priorSd = gaussianDrift({ mu: 400, sigma: 100, width: 10 })

    var sampLog = map(function(subjID) {

        var idData = _.filter(data, { subjID: subjID })

        var sdInfSamp = gaussianDrift({ mu: sdInf, sigma: infSigma, width: 0.1 })
        var sdInfId = Math.exp(sdInfSamp)

        var subLog = map(function(row) {

            var click = Math.round(row.clickScaledX)
            var targetCenterY = row.targetCenterY
            var eyeCenterLX = row.eyeCenterLeftX
            var eyeCenterLY = row.eyeCenterLeftY
            var eyeCenterRX = row.eyeCenterRightX
            var eyeCenterRY = row.eyeCenterRightY
            var pupilLX = row.pupilFinalLeftX
            var pupilLY = row.pupilFinalLeftY
            var pupilRX = row.pupilFinalRightX
            var pupilRY = row.pupilFinalRightY

            var tAlphaL = eyeCenterLX > pupilLX ?
                Math.atan(Math.abs(eyeCenterLX - pupilLX) / (eyeCenterLY - pupilLY)) :
                (-Math.atan(Math.abs(eyeCenterLX - pupilLX) / (eyeCenterLY - pupilLY)))

            var tAlphaR = eyeCenterRX > pupilRX ?
                Math.atan(Math.abs(eyeCenterRX - pupilRX) / (eyeCenterRY - pupilRY)) :
                (-Math.atan(Math.abs(eyeCenterRX - pupilRX) / (eyeCenterRY - pupilRY)))

            var lDist = map(function(coord) {

                var betaL = eyeCenterLX > coord ?
                    Math.atan(Math.abs(eyeCenterLX - coord) / (eyeCenterLY - targetCenterY)) :
                    (-Math.atan(Math.abs(eyeCenterLX - coord) / (eyeCenterLY - targetCenterY)))

                var betaLDist = Gaussian({ mu: tAlphaL, sigma: sdInfId }).score(betaL)

                return betaLDist

            }, sampleCoord)

            var rDist = map(function(coord) {

                var betaR = eyeCenterRX > coord ?
                    Math.atan(Math.abs(eyeCenterRX - coord) / (eyeCenterRY - targetCenterY)) :
                    (-Math.atan(Math.abs(eyeCenterRX - coord) / (eyeCenterRY - targetCenterY)))

                var betaRDist = Gaussian({ mu: tAlphaR, sigma: sdInfId }).score(betaR)

                return betaRDist

            }, sampleCoord)


            var lNormDist = map(function(x) {
                var lNormDist = Math.exp(x - util.logsumexp(lDist))
                return lNormDist
            }, lDist)


            var rNormDist = map(function(x) {
                var rNormDist = Math.exp(x - util.logsumexp(rDist))
                return rNormDist
            }, rDist)

            var xDist = map2(multiply, lNormDist, rNormDist)

            // Construct prior distribution

            var priorDist = map(function(coord) {

                var dist = Gaussian({ mu: 960, sigma: priorSd }).score(coord)

                return dist

            }, sampleCoord)


            var priorNormDist = map(function(x) {
                var priorNormDist = Math.exp(x - util.logsumexp(priorDist))
                return priorNormDist
            }, priorDist)

            // multiply prior by gaze distribution

            var gazePriorDist = map2(multiply, xDist, priorNormDist)


            //expand gaze distribution

            var xCoordDist = map(function(x) {
                return repeat(granularity, function() { return x; })
            }, gazePriorDist)

            var gazePred = Categorical({ ps: xCoordDist.flat(), vs: coordinates })
  
            var logInf = gazePred.score(click)
          

            // guessing model

            var guessPred = Uniform({ a: 0, b: 1920 })

            var logGuess = guessPred.score(click)

            // center bias model

            var centerPred = Gaussian({ mu: 960, sigma: 160 })

            var logCenter = centerPred.score(click) 


            return { logGuess: logGuess, logInf: logInf, logCenter: logCenter }

        }, idData)

        var subLogGuess = []
        var subLogInf = []
        var subLogCenter = []

        foreach(function(number) {
            subLogGuess.push(number.logGuess);
            subLogInf.push(number.logInf)
            subLogCenter.push(number.logCenter)
        }, subLog)


        return { 
            subLogGuess: sum(subLogGuess), 
            subLogInf: sum(subLogInf), 
            subLogCenter: sum(subLogCenter) }

    }, subjects)


    var sampLogGuess = []
    var sampLogInf = []
    var sampLogCenter = []

    foreach(function(number) {
        sampLogGuess.push(number.subLogGuess);
        sampLogInf.push(number.subLogInf)
        sampLogCenter.push(number.subLogCenter)
    }, sampLog)

    query.add([chain, "guess"], sum(sampLogGuess))
    query.add([chain, "inf"], sum(sampLogInf))
    query.add([chain, "center"], sum(sampLogCenter))


    return query

}

var header = "iteration,chain,model,loglike,score"

var output_file = 'output/adult_gaze_model_prior_hedge_model_comparison_chain' + chain + '.csv'
var callback = webpplSampleWriter.streamQueryCSV(output_file, header);

var output = Infer({
    model,
    samples: 100000,
    burn: 50000,
    lag: 0,
    method: 'MCMC',
    verbose: T,
    callbacks: [callback]
});