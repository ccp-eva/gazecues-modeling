// example call: time webppl model-inf-adults-prior.wppl --require webppl-json --require webppl-sample-writer 1

var chain = last(process.argv)

// helper functions

var foreach = function(fn, lst) {
    var foreach_ = function(i) {
        if (i < lst.length) {
            fn(lst[i]);
            foreach_(i + 1);
        }
    };
    foreach_(0);
};

var samplePosGaussian = function(mu, sigma) {
    var x = sample(Gaussian({ mu: mu, sigma: sigma }))
    return x < 0 ? samplePosGaussian(mu, sigma) : x
};

var logistic = function(x) { 1 / (1 + Math.exp(-x)) }

var multiply = function(x, y) { return x * y; };

var levels = function(df, label) {
    return _.uniq(_.map(df, label));
}

var deg2rad = function(x) {
    (x * Math.PI) / (180)
}

// data

var data = json.read('model_data/gafo_prolific_modelvalidation.json');

//var trialTypes = levels(data, "trialType")

var subjects = levels(data, "subjID")

var maxCoord = 1920

var granularity = 20

var granCoord = maxCoord / granularity

var cords = _.range(0, granCoord)

// center bias
//var centerBias = json.read('model_data/centerBias_hedge.json');

var sampleCoord = map(function(x) {
    return x * granularity;
}, cords)

var coordinates = _.range(0, 1920)

var model = function() {

    // var infInt = uniformDrift({ a: -2, b: 1, width: 0.1 })
    // var infSlope = uniformDrift({ a: -2, b: 1, width: 0.1 })
    // var sdInfSigma = uniformDrift({ a: 0, b: 0.25, width: 0.1 })

    // var guessInt = uniformDrift({ a: -2, b: 2, width: 0.1 })
    // var guessSlope = uniformDrift({ a: -2, b: 1, width: 0.1 })
    // var guessSigma = uniformDrift({ a: 0, b: 0.25, width: 0.1 })

    // var biasInt = uniformDrift({ a: -2, b: 2, width: 0.1 })
    // var biasSlope = uniformDrift({ a: -2, b: 2, width: 0.1 })
    // var biasSigma = uniformDrift({ a: 0, b: 0.25, width: 0.1 })
    var sdInf = gaussianDrift({ mu: -1, sigma: 1, width: 0.1 })
    var infSigma = uniformDrift({ a: 0, b: 1, width: 0.1 })

    var priorSd = gaussianDrift({ mu: 400, sigma: 100, width: 10 })



    foreach(function(subjID) {

        //var guess = uniformDrift({a: 0, b:1, width: 0.1})

        var idData = _.filter(data, { subjID: subjID })

        //var biasLoc = uniformDrift({ a: 0, b: 1920, width: 20 })

        //display(age)

        // var sdInfAge = infInt + infSlope * age
        // var sdInfSamp = gaussianDrift({ mu: sdInfAge, sigma: sdInfSigma, width: 0.1 })
        // var sdInfId = logistic(sdInfSamp)

        // var guessAge = guessInt + guessSlope * age
        // var guessId = gaussianDrift({ mu: guessAge, sigma: guessSigma, width: 0.1 })
        // var guess = logistic(guessId)

        // var biasAge = biasInt + biasSlope * age
        // var biasId = gaussianDrift({ mu: biasAge, sigma: biasSigma, width: 0.1 })
        // var bias = logistic(biasId)

        var sdInfSamp = gaussianDrift({ mu: sdInf, sigma: infSigma, width: 0.1 })
        var sdInfId = Math.exp(sdInfSamp)

        // var biasId = gaussianDrift({ mu: biasAge, sigma: biasSigma, width: 0.1 })
        // var bias = logistic(biasId)




        //display(idData)

        foreach(function(row) {


            //var click = row.clickScaledX
            var click = Math.round(row.clickScaledX)
                //display(click)
            //var targetPosition = row.targetPosition
            //var targetCenterX = row.targetCenterX
            var targetCenterY = row.targetCenterY
            var eyeCenterLX = row.eyeCenterLeftX
            var eyeCenterLY = row.eyeCenterLeftY
            var eyeCenterRX = row.eyeCenterRightX
            var eyeCenterRY = row.eyeCenterRightY
            var pupilLX = row.pupilFinalLeftX
            var pupilLY = row.pupilFinalLeftY
            var pupilRX = row.pupilFinalRightX
            var pupilRY = row.pupilFinalRightY

            var tAlphaL = eyeCenterLX > pupilLX ?
                Math.atan(Math.abs(eyeCenterLX - pupilLX) / (eyeCenterLY - pupilLY)) :
                (-Math.atan(Math.abs(eyeCenterLX - pupilLX) / (eyeCenterLY - pupilLY)))

            var tAlphaR = eyeCenterRX > pupilRX ?
                Math.atan(Math.abs(eyeCenterRX - pupilRX) / (eyeCenterRY - pupilRY)) :
                (-Math.atan(Math.abs(eyeCenterRX - pupilRX) / (eyeCenterRY - pupilRY)))

            //var  noisyAlphaL = gaussian(tAlphaL, sdPer)

            //var  noisyAlphaR = gaussian(tAlphaR, sdPer)


            //display([tAlphaL,tAlphaR])

            var lDist = map(function(coord) {

                var betaL = eyeCenterLX > coord ?
                    Math.atan(Math.abs(eyeCenterLX - coord) / (eyeCenterLY - targetCenterY)) :
                    (-Math.atan(Math.abs(eyeCenterLX - coord) / (eyeCenterLY - targetCenterY)))

                //var betaLDist = Gaussian({mu:noisyAlphaL,sigma:sdInf}).score(betaL)
                var betaLDist = Gaussian({ mu: tAlphaL, sigma: sdInfId }).score(betaL)

                return betaLDist

            }, sampleCoord)

            var rDist = map(function(coord) {

                var betaR = eyeCenterRX > coord ?
                    Math.atan(Math.abs(eyeCenterRX - coord) / (eyeCenterRY - targetCenterY)) :
                    (-Math.atan(Math.abs(eyeCenterRX - coord) / (eyeCenterRY - targetCenterY)))

                //var betaRDist = Gaussian({mu:noisyAlphaR,sigma:sdInf}).score(betaR)
                var betaRDist = Gaussian({ mu: tAlphaR, sigma: sdInfId }).score(betaR)

                return betaRDist

            }, sampleCoord)


            var lNormDist = map(function(x) {
                var lNormDist = Math.exp(x - util.logsumexp(lDist))
                return lNormDist
            }, lDist)


            var rNormDist = map(function(x) {
                var rNormDist = Math.exp(x - util.logsumexp(rDist))
                return rNormDist
            }, rDist)

            var xDist = map2(multiply, lNormDist, rNormDist)

            //display(xDist)

            // Construct prior distribution

            var priorDist = map(function(coord) {

                var dist = Gaussian({ mu: 960, sigma: priorSd }).score(coord)

                return dist

            }, sampleCoord)

            //display(priorDist)

            var priorNormDist = map(function(x) {
                var priorNormDist = Math.exp(x - util.logsumexp(priorDist))
                return priorNormDist
            }, priorDist)

            //display(priorNormDist)

            // multiply prior by gaze distribution

            var gazePriorDist = map2(multiply, xDist, priorNormDist)

            //display(gazePriorDist)

            //expand gaze distribution

            var xCoordDist = map(function(x) {
                return repeat(granularity, function() { return x; })
            }, gazePriorDist)

            //display(xCoordDist.flat())

            var gazePred = Categorical({ ps: xCoordDist.flat(), vs: coordinates })
          
            // var pred = flip(guess) ? flip(bias) ? Categorical({ ps: centerBias, vs: coordinates }) : Uniform({ a: 0, b: 1920 }) : gazePred

            //var pred = flip(bias) ? Gaussian({ mu: biasLoc, sigma: 100 }) : gazePred

            observe(gazePred, click)

            //var predSample = sample(pred)

            //query.add(["inference","prediction",targetPosition,targetCenterX], sample(pred))
            //display(guess)

            //},testData)
        }, idData)

        //query.add(["sd","perceptual"], sdPer)
        query.add([chain, "inference", "sd", "id", subjID], sdInfId)
        //query.add([chain, "guessing ", "guess", "id", subjID], bias)
            //query.add([chain, "bias ", "bias", "id", subjID], bias)
            //query.add(["sd","motor",], sdMot)

    }, subjects)


    query.add([chain, "inference", "sigma", "global", "NA"], infSigma)
    query.add([chain, "inference", "sd", "global", "NA"], sdInf)

    // query.add([chain, "guessing", "sigma", "global", "NA"], guessSigma)
    // query.add([chain, "guessing", "intercept", "global", "NA"], guessInt)
    // query.add([chain, "guessing", "slope", "global", "NA"], guessSlope)

    query.add([chain, "priorSd", "prior", "global", "NA"], priorSd)
    //query.add([chain, "bias", "slope", "global", "NA"], biasSlope)


    return query

}

var header = "iteration,chain,parameter,type,scope,id,value,score"

var output_file = 'output/adult_gaze_model_prior_hedge_exp_granularity' + granularity + '_chain' + chain + '.csv'
var callback = webpplSampleWriter.streamQueryCSV(output_file, header);

var output = Infer({
    model,
    samples: 50000,
    burn: 100000,
    lag: 2,
    method: 'MCMC',
    verbose: T,
    callbacks: [callback]
});